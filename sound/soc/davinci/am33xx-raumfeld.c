/*
 * ASoC driver for Raumfeld's AM33xx based audio devices
 *
 *  (c) 2012 Daniel Mack <daniel@zonque.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */


#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/timer.h>
#include <linux/interrupt.h>
#include <linux/platform_device.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <linux/pinctrl/consumer.h>

struct snd_soc_am33xx_raumfeld {
	struct snd_soc_card card;
};

static uint8_t clk0_clk1_12288000[]= {
0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0x4f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0c, 0x35, 0x00, 0x0d, 0xba, 0x00, 
0x06, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1e, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x42, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xd2, 0x60, 0x60, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

static uint8_t clk0_clk1_11289600[] = {
0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x6f, 0x4f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0xf5, 0xe1, 0x00, 0x0c, 0x1d, 0x50, 
0xd7, 0x83, 0x0c, 0x35, 0x00, 0x0b, 0x8c, 0x00, 0x02, 0x04, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x42, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xd2, 0x60, 0x60, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

static uint8_t clk0_clk1_22579200[] = {
0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x6f, 0x4f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x31, 0x2d, 0x00, 0x0c, 0x0d, 0x10, 
0x0a, 0xb7, 0x3d, 0x09, 0x00, 0x0c, 0x73, 0x00, 0x16, 0xf5, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x42, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xd2, 0x60, 0x60, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

static uint8_t clk0_clk1_24576000[]= {
0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x4f, 0x4f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0c, 0x35, 0x00, 0x0d, 0xba, 0x00, 
0x06, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x42, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xd2, 0x60, 0x60, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static int sue_init_si5351(int freq)
{
	struct i2c_adapter *adapter = i2c_get_adapter(0);
	uint8_t *regs = NULL, buf[2];
	struct i2c_msg msg;
	int i, ret, size;

	printk(KERN_ERR " %s() :: %d\n", __func__, freq);
	
	if (!adapter) {
		printk(KERN_ERR "%s(): no adapter!?\n", __func__);
		return -EIO;
	}
	
	printk(KERN_ERR " %s() :: adapter name >%s<\n", __func__, adapter->name);

	switch (freq) {
	case 12288000:
		regs = clk0_clk1_12288000;
		size = sizeof(clk0_clk1_12288000);
		break;
	case 11289600:
		regs = clk0_clk1_11289600;
		size = sizeof(clk0_clk1_11289600);
		break;
	case 22579200:
		regs = clk0_clk1_22579200;
		size = sizeof(clk0_clk1_22579200);
		break;
	case 24576000:
		regs = clk0_clk1_24576000;
		size = sizeof(clk0_clk1_24576000);
		break;
	default:
		printk(KERN_ERR "%s(): unsupported freq %d!\n", __func__, freq);
		return -EINVAL;
	}

	memset(&msg, 0, sizeof(msg));

	msg.addr = 0x60;
	msg.buf = buf;
	msg.len = sizeof(buf);

	for (i = 0; i < 183; i++) {
		buf[0] = i;
		buf[1] = regs[i];
		ret = i2c_transfer(adapter, &msg, 1);
		mdelay(1);
		if (ret < 0) {
			printk(KERN_ERR " %s() write #%d failed\n", __func__, i);	
			return ret;
		}
	}

	printk(KERN_ERR " >>> %s(): SENT %d bytes\n", __func__, size);

	return 0;
}

static int raumfeld_i2s_hw_params(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params *params)
{
	/* SUE */
	struct snd_soc_pcm_runtime *rtd = substream->private_data;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	int ret = 0;
	unsigned int div;
	unsigned int clk;
	unsigned int framerate;
	unsigned int bitrate;
	unsigned int dai_fmt;
	unsigned int playback;

	framerate = params_rate(params);

	playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
	pr_info("SUE HW params entered. params:%d, playback:%d",framerate, playback);

	dai_fmt = 0;

	switch (framerate) {
	case 16000:
	case 32000:
	case 48000:
	case 96000:
	case 192000:
		clk = 12288000 * 2;
		break;
	case 22050:
	case 44100:
	case 88200:
	case 176000:
		clk = 11289600 * 2;
		break;
	default:
		printk(KERN_DEBUG "SUE Audio: Not supported samplerate %d\n",params_rate(params));
		return -1;
	}

	/* Master clock */
	pr_info("clk:%d",clk);

	/* FIXME: setup the clock frequency */
	sue_init_si5351(clk);

	/* setup the CPU DAI */
	bitrate = 32;

	div = clk / (bitrate * framerate * 2);

	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, clk, SND_SOC_CLOCK_IN);
	if (ret < 0)
		return ret;

	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, 1);
	ret = snd_soc_dai_set_clkdiv(cpu_dai, 1, div);

	/* BCLK-to_LRCLK divider ratio */
	ret = snd_soc_dai_set_clkdiv(cpu_dai, 2, 64);
	if (ret < 0)
		return ret;

	/* setup the CODEC DAI */
	ret = snd_soc_dai_set_sysclk(codec_dai, 0, clk, SND_SOC_CLOCK_IN);

	return ret;
}

static struct snd_soc_ops raumfeld_dai_link_ops = {
	.hw_params = raumfeld_i2s_hw_params,
};

#define RAUMFELD_DAI_FMT \
	(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_NB_NF)

static struct snd_soc_dai_link raumfeld_dai_links[] = {
	{
		.name		= "analog",
		.stream_name	= "I2S",
		.ops		= &raumfeld_dai_link_ops,
		.dai_fmt	= RAUMFELD_DAI_FMT,
	},
	{
		.name		= "s/pdif",
		.stream_name	= "I2S",
		.ops		= &raumfeld_dai_link_ops,
		.dai_fmt	= RAUMFELD_DAI_FMT,
	},
};

static int __devinit snd_soc_am33xx_raumfeld_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct device_node *node, *np = dev->of_node;
	struct snd_soc_am33xx_raumfeld *raumfeld;
	struct pinctrl *pinctrl;
	int ret;

	if (!np)
		return -ENODEV;

	raumfeld = devm_kzalloc(dev, sizeof(struct snd_soc_am33xx_raumfeld),
				GFP_KERNEL);
	if (!raumfeld)
		return -ENOMEM;

	/* request pin mux */
	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
	if (IS_ERR(pinctrl))
		dev_warn(&pdev->dev, "pins are not configured from the driver\n");

	raumfeld->card.dai_link = raumfeld_dai_links;
	raumfeld->card.num_links = ARRAY_SIZE(raumfeld_dai_links);

	raumfeld->card.dev = &pdev->dev;
	snd_soc_of_parse_card_name(&raumfeld->card, "raumfeld,card-name");

	node = of_parse_phandle(np, "raumfeld,platform", 0);
	if (!node) {
		dev_err(dev, "property 'raumfeld,platform' missing.\n");
		return -EINVAL;
	}
	raumfeld_dai_links[0].platform_of_node = node;
	raumfeld_dai_links[1].platform_of_node = node;

	of_property_read_string(np, "raumfeld,cpu-dai-name",
				&raumfeld_dai_links[0].cpu_dai_name);
	of_property_read_string(np, "raumfeld,cpu-dai-name",
				&raumfeld_dai_links[1].cpu_dai_name);

	node = of_parse_phandle(np, "raumfeld,analog-codec", 0);
	if (!node) {
		dev_err(dev, "property 'raumfeld,analog-codec' missing.\n");
		return -EINVAL;
	}
	raumfeld_dai_links[0].codec_of_node = node;
	of_property_read_string(np, "raumfeld,analog-codec-dai-name",
				&raumfeld_dai_links[0].codec_dai_name);

	node = of_parse_phandle(np, "raumfeld,spdif-transmitter", 0);
	if (!node) {
		dev_err(dev, "property 'raumfeld,spdif-transmitter' missing.\n");
		return -EINVAL;
	}
	raumfeld_dai_links[1].codec_of_node = node;
	of_property_read_string(np, "raumfeld,spdif-transmitter-dai-name",
				&raumfeld_dai_links[1].codec_dai_name);

	platform_set_drvdata(pdev, &raumfeld->card);
	snd_soc_card_set_drvdata(&raumfeld->card, raumfeld);

	ret = snd_soc_register_card(&raumfeld->card);
	if (ret < 0)
		dev_err(&pdev->dev, "error registering card (%d)\n", ret);

	return ret;
}

static int __devexit snd_soc_am33xx_raumfeld_remove(struct platform_device *pdev)
{

	return 0;
}

static const struct of_device_id snd_soc_am33xx_raumfeld_match[] = {
	{ .compatible = "raumfeld,am33xx-connector-audio", },
	{ }
};

static struct platform_driver snd_soc_am33xx_raumfeld_driver = {
	.driver = {
		.owner = THIS_MODULE,
		.name = "snd-soc-am33xx-raumfeld",
		.of_match_table = snd_soc_am33xx_raumfeld_match,
	},
	.probe = snd_soc_am33xx_raumfeld_probe,
	.remove = __devexit_p(snd_soc_am33xx_raumfeld_remove),
};

module_platform_driver(snd_soc_am33xx_raumfeld_driver);
